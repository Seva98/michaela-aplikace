-- Table: public.michaela_users

-- DROP TABLE IF EXISTS public.michaela_users;

CREATE TABLE IF NOT EXISTS public.michaela_users
(
    user_id integer NOT NULL DEFAULT nextval('michaela_users_user_id_seq'::regclass),
    first_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    last_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    email character varying(100) COLLATE pg_catalog."default" NOT NULL,
    phone character varying(20) COLLATE pg_catalog."default",
    bio text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    birthday date,
    address character varying(255) COLLATE pg_catalog."default",
    image character varying(255) COLLATE pg_catalog."default",
    color character varying(7) COLLATE pg_catalog."default" DEFAULT '#000000'::character varying,
    "order" integer NOT NULL,
    is_hidden boolean NOT NULL DEFAULT false,
    CONSTRAINT michaela_users_pkey PRIMARY KEY (user_id),
    CONSTRAINT michaela_users_email_key UNIQUE (email)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.michaela_users
    OWNER to "default";-- Table: public.michaela_users

-- DROP TABLE IF EXISTS public.michaela_users;

CREATE TABLE IF NOT EXISTS public.michaela_users
(
    user_id integer NOT NULL DEFAULT nextval('michaela_users_user_id_seq'::regclass),
    first_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    last_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    email character varying(100) COLLATE pg_catalog."default" NOT NULL,
    phone character varying(20) COLLATE pg_catalog."default",
    bio text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    birthday date,
    address character varying(255) COLLATE pg_catalog."default",
    image character varying(255) COLLATE pg_catalog."default",
    color character varying(7) COLLATE pg_catalog."default" DEFAULT '#000000'::character varying,
    "order" integer NOT NULL,
    is_hidden boolean NOT NULL DEFAULT false,
    CONSTRAINT michaela_users_pkey PRIMARY KEY (user_id),
    CONSTRAINT michaela_users_email_key UNIQUE (email)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.michaela_users
    OWNER to "default";-- Table: public.michaela_sessions

-- DROP TABLE IF EXISTS public.michaela_sessions;

CREATE TABLE IF NOT EXISTS public.michaela_sessions
(
    session_id integer NOT NULL DEFAULT nextval('michaela_sessions_session_id_seq'::regclass),
    user_subscription_id integer NOT NULL,
    session_date date NOT NULL,
    note character varying(1000) COLLATE pg_catalog."default",
    rating integer NOT NULL DEFAULT 1,
    CONSTRAINT michaela_sessions_pkey PRIMARY KEY (session_id),
    CONSTRAINT fk_user_subscription_id FOREIGN KEY (user_subscription_id)
        REFERENCES public.michaela_user_subscriptions (user_subscription_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT michaela_sessions_user_subscription_id_fkey FOREIGN KEY (user_subscription_id)
        REFERENCES public.michaela_user_subscriptions (user_subscription_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT rating_check CHECK (rating >= 1 AND rating <= 10)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.michaela_sessions
    OWNER to "default";

-- Trigger: trigger_check_session_count

-- DROP TRIGGER IF EXISTS trigger_check_session_count ON public.michaela_sessions;

CREATE OR REPLACE TRIGGER trigger_check_session_count
    BEFORE INSERT
    ON public.michaela_sessions
    FOR EACH ROW
    EXECUTE FUNCTION public.check_session_count();

-- Trigger: trigger_update_is_completed

-- DROP TRIGGER IF EXISTS trigger_update_is_completed ON public.michaela_sessions;

CREATE OR REPLACE TRIGGER trigger_update_is_completed
    AFTER INSERT OR UPDATE 
    ON public.michaela_sessions
    FOR EACH ROW
    EXECUTE FUNCTION public.update_is_completed();-- Table: public.michaela_user_subscriptions

-- DROP TABLE IF EXISTS public.michaela_user_subscriptions;

CREATE TABLE IF NOT EXISTS public.michaela_user_subscriptions
(
    user_subscription_id integer NOT NULL DEFAULT nextval('michaela_user_subscriptions_user_subscription_id_seq'::regclass),
    user_id integer NOT NULL,
    subscription_id integer NOT NULL,
    start_date date NOT NULL,
    is_completed boolean DEFAULT false,
    completion_date date,
    CONSTRAINT michaela_user_subscriptions_pkey PRIMARY KEY (user_subscription_id),
    CONSTRAINT fk_subscription_id FOREIGN KEY (subscription_id)
        REFERENCES public.michaela_subscriptions (subscription_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT fk_user_id FOREIGN KEY (user_id)
        REFERENCES public.michaela_users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT michaela_user_subscriptions_subscription_id_fkey FOREIGN KEY (subscription_id)
        REFERENCES public.michaela_subscriptions (subscription_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT michaela_user_subscriptions_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.michaela_users (user_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.michaela_user_subscriptions
    OWNER to "default";-- SEQUENCE: public.michaela_sessions_session_id_seq

-- DROP SEQUENCE IF EXISTS public.michaela_sessions_session_id_seq;

CREATE SEQUENCE IF NOT EXISTS public.michaela_sessions_session_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;

ALTER SEQUENCE public.michaela_sessions_session_id_seq
    OWNED BY public.michaela_sessions.session_id;

ALTER SEQUENCE public.michaela_sessions_session_id_seq
    OWNER TO "default";-- SEQUENCE: public.michaela_users_user_id_seq

-- DROP SEQUENCE IF EXISTS public.michaela_users_user_id_seq;

CREATE SEQUENCE IF NOT EXISTS public.michaela_users_user_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;

ALTER SEQUENCE public.michaela_users_user_id_seq
    OWNED BY public.michaela_users.user_id;

ALTER SEQUENCE public.michaela_users_user_id_seq
    OWNER TO "default";-- SEQUENCE: public.michaela_subscriptions_subscription_id_seq

-- DROP SEQUENCE IF EXISTS public.michaela_subscriptions_subscription_id_seq;

CREATE SEQUENCE IF NOT EXISTS public.michaela_subscriptions_subscription_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;

ALTER SEQUENCE public.michaela_subscriptions_subscription_id_seq
    OWNED BY public.michaela_subscriptions.subscription_id;

ALTER SEQUENCE public.michaela_subscriptions_subscription_id_seq
    OWNER TO "default";-- SEQUENCE: public.michaela_user_subscriptions_user_subscription_id_seq

-- DROP SEQUENCE IF EXISTS public.michaela_user_subscriptions_user_subscription_id_seq;

CREATE SEQUENCE IF NOT EXISTS public.michaela_user_subscriptions_user_subscription_id_seq
    INCREMENT 1
    START 1
    MINVALUE 1
    MAXVALUE 2147483647
    CACHE 1;

ALTER SEQUENCE public.michaela_user_subscriptions_user_subscription_id_seq
    OWNED BY public.michaela_user_subscriptions.user_subscription_id;

ALTER SEQUENCE public.michaela_user_subscriptions_user_subscription_id_seq
    OWNER TO "default";-- FUNCTION: public.resequence_orders(text, text, text)

-- DROP FUNCTION IF EXISTS public.resequence_orders(text, text, text);

CREATE OR REPLACE FUNCTION public.resequence_orders(
	table_name text,
	order_column text,
	id_column text)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    r RECORD;
    i INT := 1;
    dynamic_query TEXT;
BEGIN
    dynamic_query := format('SELECT %I as id FROM %I ORDER BY %I', id_column, table_name, order_column);
    
    FOR r IN EXECUTE dynamic_query LOOP
        EXECUTE format('UPDATE %I SET %I = %L WHERE %I = %L', table_name, order_column, i, id_column, r.id);
        i := i + 1;
    END LOOP;
END;
$BODY$;

ALTER FUNCTION public.resequence_orders(text, text, text)
    OWNER TO "default";
-- FUNCTION: public.adjust_subscription_order(integer, integer)

-- DROP FUNCTION IF EXISTS public.adjust_subscription_order(integer, integer);

CREATE OR REPLACE FUNCTION public.adjust_subscription_order(
	p_subscription_id integer,
	p_amount integer)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE
    current_order INT;
    new_order INT;
BEGIN
    -- Get the current order of the passed subscription_id
    SELECT "order" INTO current_order
    FROM michaela_subscriptions
    WHERE subscription_id = p_subscription_id;

    -- Calculate the new order
    new_order := current_order + p_amount;

    -- Check if the new order is valid
    IF new_order < 1 THEN
        RAISE EXCEPTION 'The new order value must be greater than or equal to 1.';
    END IF;

    -- Check if the new order is greater or less
    IF p_amount > 0 THEN
        -- Increment orders of all subscriptions between current_order and new_order
        UPDATE michaela_subscriptions
        SET "order" = "order" - 1
        WHERE "order" > current_order AND "order" <= new_order;
    ELSE
        -- Decrement orders of all subscriptions between new_order and current_order
        UPDATE michaela_subscriptions
        SET "order" = "order" + 1
        WHERE "order" < current_order AND "order" >= new_order;
    END IF;

    -- Update the order of the passed subscription_id
    UPDATE michaela_subscriptions
    SET "order" = new_order
    WHERE subscription_id = p_subscription_id;
END;
$BODY$;

ALTER FUNCTION public.adjust_subscription_order(integer, integer)
    OWNER TO "default";
-- View: public.michaela_user_active_subscription

-- DROP VIEW public.michaela_user_active_subscription;

CREATE OR REPLACE VIEW public.michaela_user_active_subscription
 AS
 SELECT u.user_id,
    u.first_name,
    u.last_name,
    us.user_subscription_id,
    s.name AS subscription_name,
    s.number_of_sessions,
    us.start_date + s.expiration_days::double precision * '1 day'::interval AS expiration_date,
    s.number_of_sessions - COALESCE(count(sess.session_id), 0::bigint) AS sessions_remaining
   FROM michaela_users u
     LEFT JOIN michaela_user_subscriptions us ON u.user_id = us.user_id
     LEFT JOIN michaela_subscriptions s ON us.subscription_id = s.subscription_id
     LEFT JOIN michaela_sessions sess ON us.user_subscription_id = sess.user_subscription_id
  GROUP BY u.user_id, u.first_name, u.last_name, us.user_subscription_id, s.name, s.number_of_sessions, us.start_date, s.expiration_days;

ALTER TABLE public.michaela_user_active_subscription
    OWNER TO "default";

-- FUNCTION: public.check_session_count()

-- DROP FUNCTION IF EXISTS public.check_session_count();

CREATE OR REPLACE FUNCTION public.check_session_count()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Check the number of sessions already booked for the subscription
    IF (
        SELECT COUNT(*) 
        FROM michaela_sessions 
        WHERE user_subscription_id = NEW.user_subscription_id
    ) >= (
        SELECT number_of_sessions 
        FROM michaela_subscriptions 
        WHERE subscription_id = (SELECT subscription_id FROM michaela_user_subscriptions WHERE user_subscription_id = NEW.user_subscription_id)
    ) THEN
        RAISE EXCEPTION 'Cannot book more sessions than allowed for this subscription';
    END IF;
    
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.check_session_count()
    OWNER TO "default";
-- FUNCTION: public.update_is_completed()

-- DROP FUNCTION IF EXISTS public.update_is_completed();

CREATE OR REPLACE FUNCTION public.update_is_completed()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
BEGIN
    -- Check if the number of sessions equals or exceeds the number_of_sessions defined in michaela_subscriptions
    IF (
        SELECT COUNT(*) 
        FROM michaela_sessions 
        WHERE user_subscription_id = NEW.user_subscription_id
    ) >= (
        SELECT number_of_sessions 
        FROM michaela_subscriptions s
        WHERE s.subscription_id = (
            SELECT us.subscription_id 
            FROM michaela_user_subscriptions us 
            WHERE us.user_subscription_id = NEW.user_subscription_id
        )
    ) THEN
        -- Mark as completed and set completion_date to NOW()
        UPDATE michaela_user_subscriptions
        SET is_completed = TRUE,
            completion_date = NOW()
        WHERE user_subscription_id = NEW.user_subscription_id;
    ELSE
        -- Mark as not completed and set completion_date to NULL
        UPDATE michaela_user_subscriptions
        SET is_completed = FALSE,
            completion_date = NULL
        WHERE user_subscription_id = NEW.user_subscription_id;
    END IF;
    
    RETURN NEW;
END;
$BODY$;

ALTER FUNCTION public.update_is_completed()
    OWNER TO "default";
